// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file Camera.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "Camera.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

joyson::sensor::camera::TimeStamp::TimeStamp()
{
    // m_Second com.eprosima.idl.parser.typecode.PrimitiveTypeCode@52f759d7
    m_Second = 0;
    // m_Millisecond com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7cbd213e
    m_Millisecond = 0;
    // m_Nanoseconds com.eprosima.idl.parser.typecode.PrimitiveTypeCode@192d3247
    m_Nanoseconds = 0;

}

joyson::sensor::camera::TimeStamp::~TimeStamp()
{



}

joyson::sensor::camera::TimeStamp::TimeStamp(
        const TimeStamp& x)
{
    m_Second = x.m_Second;
    m_Millisecond = x.m_Millisecond;
    m_Nanoseconds = x.m_Nanoseconds;
}

joyson::sensor::camera::TimeStamp::TimeStamp(
        TimeStamp&& x) noexcept 
{
    m_Second = x.m_Second;
    m_Millisecond = x.m_Millisecond;
    m_Nanoseconds = x.m_Nanoseconds;
}

joyson::sensor::camera::TimeStamp& joyson::sensor::camera::TimeStamp::operator =(
        const TimeStamp& x)
{

    m_Second = x.m_Second;
    m_Millisecond = x.m_Millisecond;
    m_Nanoseconds = x.m_Nanoseconds;

    return *this;
}

joyson::sensor::camera::TimeStamp& joyson::sensor::camera::TimeStamp::operator =(
        TimeStamp&& x) noexcept
{

    m_Second = x.m_Second;
    m_Millisecond = x.m_Millisecond;
    m_Nanoseconds = x.m_Nanoseconds;

    return *this;
}

bool joyson::sensor::camera::TimeStamp::operator ==(
        const TimeStamp& x) const
{

    return (m_Second == x.m_Second && m_Millisecond == x.m_Millisecond && m_Nanoseconds == x.m_Nanoseconds);
}

bool joyson::sensor::camera::TimeStamp::operator !=(
        const TimeStamp& x) const
{
    return !(*this == x);
}

size_t joyson::sensor::camera::TimeStamp::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t joyson::sensor::camera::TimeStamp::getCdrSerializedSize(
        const joyson::sensor::camera::TimeStamp& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void joyson::sensor::camera::TimeStamp::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_Second;
    scdr << m_Millisecond;
    scdr << m_Nanoseconds;

}

void joyson::sensor::camera::TimeStamp::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_Second;
    dcdr >> m_Millisecond;
    dcdr >> m_Nanoseconds;
}

/*!
 * @brief This function sets a value in member Second
 * @param _Second New value for member Second
 */
void joyson::sensor::camera::TimeStamp::Second(
        uint64_t _Second)
{
    m_Second = _Second;
}

/*!
 * @brief This function returns the value of member Second
 * @return Value of member Second
 */
uint64_t joyson::sensor::camera::TimeStamp::Second() const
{
    return m_Second;
}

/*!
 * @brief This function returns a reference to member Second
 * @return Reference to member Second
 */
uint64_t& joyson::sensor::camera::TimeStamp::Second()
{
    return m_Second;
}

/*!
 * @brief This function sets a value in member Millisecond
 * @param _Millisecond New value for member Millisecond
 */
void joyson::sensor::camera::TimeStamp::Millisecond(
        uint64_t _Millisecond)
{
    m_Millisecond = _Millisecond;
}

/*!
 * @brief This function returns the value of member Millisecond
 * @return Value of member Millisecond
 */
uint64_t joyson::sensor::camera::TimeStamp::Millisecond() const
{
    return m_Millisecond;
}

/*!
 * @brief This function returns a reference to member Millisecond
 * @return Reference to member Millisecond
 */
uint64_t& joyson::sensor::camera::TimeStamp::Millisecond()
{
    return m_Millisecond;
}

/*!
 * @brief This function sets a value in member Nanoseconds
 * @param _Nanoseconds New value for member Nanoseconds
 */
void joyson::sensor::camera::TimeStamp::Nanoseconds(
        uint64_t _Nanoseconds)
{
    m_Nanoseconds = _Nanoseconds;
}

/*!
 * @brief This function returns the value of member Nanoseconds
 * @return Value of member Nanoseconds
 */
uint64_t joyson::sensor::camera::TimeStamp::Nanoseconds() const
{
    return m_Nanoseconds;
}

/*!
 * @brief This function returns a reference to member Nanoseconds
 * @return Reference to member Nanoseconds
 */
uint64_t& joyson::sensor::camera::TimeStamp::Nanoseconds()
{
    return m_Nanoseconds;
}


size_t joyson::sensor::camera::TimeStamp::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool joyson::sensor::camera::TimeStamp::isKeyDefined()
{
    return false;
}

void joyson::sensor::camera::TimeStamp::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

joyson::sensor::camera::ChannelFrame::ChannelFrame()
{
    // m_TriggerTimeStamp com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@679b62af

    // m_ChnTimeStamp com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@679b62af

    // m_Vaild com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5cdd8682
    m_Vaild = false;
    // m_CameraID com.eprosima.idl.parser.typecode.PrimitiveTypeCode@d6da883
    m_CameraID = 0;
    // m_ColorSpace com.eprosima.idl.parser.typecode.PrimitiveTypeCode@45afc369
    m_ColorSpace = 0;
    // m_Width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@799d4f69
    m_Width = 0;
    // m_Height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@49c43f4e
    m_Height = 0;
    // m_Size com.eprosima.idl.parser.typecode.PrimitiveTypeCode@290dbf45
    m_Size = 0;
    // m_Format com.eprosima.idl.parser.typecode.PrimitiveTypeCode@12028586
    m_Format = 0;
    // m_Offset com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2d127a61
    m_Offset = 0;
    // m_Bits com.eprosima.idl.parser.typecode.ArrayTypeCode@2bbaf4f0
    memset(&m_Bits, 0, (1920*1080*2+4096) * 1);

}

joyson::sensor::camera::ChannelFrame::~ChannelFrame()
{











}

joyson::sensor::camera::ChannelFrame::ChannelFrame(
        const ChannelFrame& x)
{
    m_TriggerTimeStamp = x.m_TriggerTimeStamp;
    m_ChnTimeStamp = x.m_ChnTimeStamp;
    m_Vaild = x.m_Vaild;
    m_CameraID = x.m_CameraID;
    m_ColorSpace = x.m_ColorSpace;
    m_Width = x.m_Width;
    m_Height = x.m_Height;
    m_Size = x.m_Size;
    m_Format = x.m_Format;
    m_Offset = x.m_Offset;
    m_Bits = x.m_Bits;
}

joyson::sensor::camera::ChannelFrame::ChannelFrame(
        ChannelFrame&& x) noexcept 
{
    m_TriggerTimeStamp = std::move(x.m_TriggerTimeStamp);
    m_ChnTimeStamp = std::move(x.m_ChnTimeStamp);
    m_Vaild = x.m_Vaild;
    m_CameraID = x.m_CameraID;
    m_ColorSpace = x.m_ColorSpace;
    m_Width = x.m_Width;
    m_Height = x.m_Height;
    m_Size = x.m_Size;
    m_Format = x.m_Format;
    m_Offset = x.m_Offset;
    m_Bits = std::move(x.m_Bits);
}

joyson::sensor::camera::ChannelFrame& joyson::sensor::camera::ChannelFrame::operator =(
        const ChannelFrame& x)
{

    m_TriggerTimeStamp = x.m_TriggerTimeStamp;
    m_ChnTimeStamp = x.m_ChnTimeStamp;
    m_Vaild = x.m_Vaild;
    m_CameraID = x.m_CameraID;
    m_ColorSpace = x.m_ColorSpace;
    m_Width = x.m_Width;
    m_Height = x.m_Height;
    m_Size = x.m_Size;
    m_Format = x.m_Format;
    m_Offset = x.m_Offset;
    m_Bits = x.m_Bits;

    return *this;
}

joyson::sensor::camera::ChannelFrame& joyson::sensor::camera::ChannelFrame::operator =(
        ChannelFrame&& x) noexcept
{

    m_TriggerTimeStamp = std::move(x.m_TriggerTimeStamp);
    m_ChnTimeStamp = std::move(x.m_ChnTimeStamp);
    m_Vaild = x.m_Vaild;
    m_CameraID = x.m_CameraID;
    m_ColorSpace = x.m_ColorSpace;
    m_Width = x.m_Width;
    m_Height = x.m_Height;
    m_Size = x.m_Size;
    m_Format = x.m_Format;
    m_Offset = x.m_Offset;
    m_Bits = std::move(x.m_Bits);

    return *this;
}

bool joyson::sensor::camera::ChannelFrame::operator ==(
        const ChannelFrame& x) const
{

    return (m_TriggerTimeStamp == x.m_TriggerTimeStamp && m_ChnTimeStamp == x.m_ChnTimeStamp && m_Vaild == x.m_Vaild && m_CameraID == x.m_CameraID && m_ColorSpace == x.m_ColorSpace && m_Width == x.m_Width && m_Height == x.m_Height && m_Size == x.m_Size && m_Format == x.m_Format && m_Offset == x.m_Offset && m_Bits == x.m_Bits);
}

bool joyson::sensor::camera::ChannelFrame::operator !=(
        const ChannelFrame& x) const
{
    return !(*this == x);
}

size_t joyson::sensor::camera::ChannelFrame::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += joyson::sensor::camera::TimeStamp::getMaxCdrSerializedSize(current_alignment);
    current_alignment += joyson::sensor::camera::TimeStamp::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += ((1920*1080*2+4096) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t joyson::sensor::camera::ChannelFrame::getCdrSerializedSize(
        const joyson::sensor::camera::ChannelFrame& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += joyson::sensor::camera::TimeStamp::getCdrSerializedSize(data.TriggerTimeStamp(), current_alignment);
    current_alignment += joyson::sensor::camera::TimeStamp::getCdrSerializedSize(data.ChnTimeStamp(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    if ((1920*1080*2+4096) > 0)
    {
        current_alignment += ((1920*1080*2+4096) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }


    return current_alignment - initial_alignment;
}

void joyson::sensor::camera::ChannelFrame::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_TriggerTimeStamp;
    scdr << m_ChnTimeStamp;
    scdr << m_Vaild;
    scdr << m_CameraID;
    scdr << m_ColorSpace;
    scdr << m_Width;
    scdr << m_Height;
    scdr << m_Size;
    scdr << m_Format;
    scdr << m_Offset;
    scdr << m_Bits;


}

void joyson::sensor::camera::ChannelFrame::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_TriggerTimeStamp;
    dcdr >> m_ChnTimeStamp;
    dcdr >> m_Vaild;
    dcdr >> m_CameraID;
    dcdr >> m_ColorSpace;
    dcdr >> m_Width;
    dcdr >> m_Height;
    dcdr >> m_Size;
    dcdr >> m_Format;
    dcdr >> m_Offset;
    dcdr >> m_Bits;

}

/*!
 * @brief This function copies the value in member TriggerTimeStamp
 * @param _TriggerTimeStamp New value to be copied in member TriggerTimeStamp
 */
void joyson::sensor::camera::ChannelFrame::TriggerTimeStamp(
        const joyson::sensor::camera::TimeStamp& _TriggerTimeStamp)
{
    m_TriggerTimeStamp = _TriggerTimeStamp;
}

/*!
 * @brief This function moves the value in member TriggerTimeStamp
 * @param _TriggerTimeStamp New value to be moved in member TriggerTimeStamp
 */
void joyson::sensor::camera::ChannelFrame::TriggerTimeStamp(
        joyson::sensor::camera::TimeStamp&& _TriggerTimeStamp)
{
    m_TriggerTimeStamp = std::move(_TriggerTimeStamp);
}

/*!
 * @brief This function returns a constant reference to member TriggerTimeStamp
 * @return Constant reference to member TriggerTimeStamp
 */
const joyson::sensor::camera::TimeStamp& joyson::sensor::camera::ChannelFrame::TriggerTimeStamp() const
{
    return m_TriggerTimeStamp;
}

/*!
 * @brief This function returns a reference to member TriggerTimeStamp
 * @return Reference to member TriggerTimeStamp
 */
joyson::sensor::camera::TimeStamp& joyson::sensor::camera::ChannelFrame::TriggerTimeStamp()
{
    return m_TriggerTimeStamp;
}
/*!
 * @brief This function copies the value in member ChnTimeStamp
 * @param _ChnTimeStamp New value to be copied in member ChnTimeStamp
 */
void joyson::sensor::camera::ChannelFrame::ChnTimeStamp(
        const joyson::sensor::camera::TimeStamp& _ChnTimeStamp)
{
    m_ChnTimeStamp = _ChnTimeStamp;
}

/*!
 * @brief This function moves the value in member ChnTimeStamp
 * @param _ChnTimeStamp New value to be moved in member ChnTimeStamp
 */
void joyson::sensor::camera::ChannelFrame::ChnTimeStamp(
        joyson::sensor::camera::TimeStamp&& _ChnTimeStamp)
{
    m_ChnTimeStamp = std::move(_ChnTimeStamp);
}

/*!
 * @brief This function returns a constant reference to member ChnTimeStamp
 * @return Constant reference to member ChnTimeStamp
 */
const joyson::sensor::camera::TimeStamp& joyson::sensor::camera::ChannelFrame::ChnTimeStamp() const
{
    return m_ChnTimeStamp;
}

/*!
 * @brief This function returns a reference to member ChnTimeStamp
 * @return Reference to member ChnTimeStamp
 */
joyson::sensor::camera::TimeStamp& joyson::sensor::camera::ChannelFrame::ChnTimeStamp()
{
    return m_ChnTimeStamp;
}
/*!
 * @brief This function sets a value in member Vaild
 * @param _Vaild New value for member Vaild
 */
void joyson::sensor::camera::ChannelFrame::Vaild(
        bool _Vaild)
{
    m_Vaild = _Vaild;
}

/*!
 * @brief This function returns the value of member Vaild
 * @return Value of member Vaild
 */
bool joyson::sensor::camera::ChannelFrame::Vaild() const
{
    return m_Vaild;
}

/*!
 * @brief This function returns a reference to member Vaild
 * @return Reference to member Vaild
 */
bool& joyson::sensor::camera::ChannelFrame::Vaild()
{
    return m_Vaild;
}

/*!
 * @brief This function sets a value in member CameraID
 * @param _CameraID New value for member CameraID
 */
void joyson::sensor::camera::ChannelFrame::CameraID(
        uint8_t _CameraID)
{
    m_CameraID = _CameraID;
}

/*!
 * @brief This function returns the value of member CameraID
 * @return Value of member CameraID
 */
uint8_t joyson::sensor::camera::ChannelFrame::CameraID() const
{
    return m_CameraID;
}

/*!
 * @brief This function returns a reference to member CameraID
 * @return Reference to member CameraID
 */
uint8_t& joyson::sensor::camera::ChannelFrame::CameraID()
{
    return m_CameraID;
}

/*!
 * @brief This function sets a value in member ColorSpace
 * @param _ColorSpace New value for member ColorSpace
 */
void joyson::sensor::camera::ChannelFrame::ColorSpace(
        uint16_t _ColorSpace)
{
    m_ColorSpace = _ColorSpace;
}

/*!
 * @brief This function returns the value of member ColorSpace
 * @return Value of member ColorSpace
 */
uint16_t joyson::sensor::camera::ChannelFrame::ColorSpace() const
{
    return m_ColorSpace;
}

/*!
 * @brief This function returns a reference to member ColorSpace
 * @return Reference to member ColorSpace
 */
uint16_t& joyson::sensor::camera::ChannelFrame::ColorSpace()
{
    return m_ColorSpace;
}

/*!
 * @brief This function sets a value in member Width
 * @param _Width New value for member Width
 */
void joyson::sensor::camera::ChannelFrame::Width(
        uint16_t _Width)
{
    m_Width = _Width;
}

/*!
 * @brief This function returns the value of member Width
 * @return Value of member Width
 */
uint16_t joyson::sensor::camera::ChannelFrame::Width() const
{
    return m_Width;
}

/*!
 * @brief This function returns a reference to member Width
 * @return Reference to member Width
 */
uint16_t& joyson::sensor::camera::ChannelFrame::Width()
{
    return m_Width;
}

/*!
 * @brief This function sets a value in member Height
 * @param _Height New value for member Height
 */
void joyson::sensor::camera::ChannelFrame::Height(
        uint16_t _Height)
{
    m_Height = _Height;
}

/*!
 * @brief This function returns the value of member Height
 * @return Value of member Height
 */
uint16_t joyson::sensor::camera::ChannelFrame::Height() const
{
    return m_Height;
}

/*!
 * @brief This function returns a reference to member Height
 * @return Reference to member Height
 */
uint16_t& joyson::sensor::camera::ChannelFrame::Height()
{
    return m_Height;
}

/*!
 * @brief This function sets a value in member Size
 * @param _Size New value for member Size
 */
void joyson::sensor::camera::ChannelFrame::Size(
        uint64_t _Size)
{
    m_Size = _Size;
}

/*!
 * @brief This function returns the value of member Size
 * @return Value of member Size
 */
uint64_t joyson::sensor::camera::ChannelFrame::Size() const
{
    return m_Size;
}

/*!
 * @brief This function returns a reference to member Size
 * @return Reference to member Size
 */
uint64_t& joyson::sensor::camera::ChannelFrame::Size()
{
    return m_Size;
}

/*!
 * @brief This function sets a value in member Format
 * @param _Format New value for member Format
 */
void joyson::sensor::camera::ChannelFrame::Format(
        uint64_t _Format)
{
    m_Format = _Format;
}

/*!
 * @brief This function returns the value of member Format
 * @return Value of member Format
 */
uint64_t joyson::sensor::camera::ChannelFrame::Format() const
{
    return m_Format;
}

/*!
 * @brief This function returns a reference to member Format
 * @return Reference to member Format
 */
uint64_t& joyson::sensor::camera::ChannelFrame::Format()
{
    return m_Format;
}

/*!
 * @brief This function sets a value in member Offset
 * @param _Offset New value for member Offset
 */
void joyson::sensor::camera::ChannelFrame::Offset(
        uint64_t _Offset)
{
    m_Offset = _Offset;
}

/*!
 * @brief This function returns the value of member Offset
 * @return Value of member Offset
 */
uint64_t joyson::sensor::camera::ChannelFrame::Offset() const
{
    return m_Offset;
}

/*!
 * @brief This function returns a reference to member Offset
 * @return Reference to member Offset
 */
uint64_t& joyson::sensor::camera::ChannelFrame::Offset()
{
    return m_Offset;
}

/*!
 * @brief This function copies the value in member Bits
 * @param _Bits New value to be copied in member Bits
 */
void joyson::sensor::camera::ChannelFrame::Bits(
        const std::array<uint8_t, 1920*1080*2+4096>& _Bits)
{
    m_Bits = _Bits;
}

/*!
 * @brief This function moves the value in member Bits
 * @param _Bits New value to be moved in member Bits
 */
void joyson::sensor::camera::ChannelFrame::Bits(
        std::array<uint8_t, 1920*1080*2+4096>&& _Bits)
{
    m_Bits = std::move(_Bits);
}

/*!
 * @brief This function returns a constant reference to member Bits
 * @return Constant reference to member Bits
 */
const std::array<uint8_t, 1920*1080*2+4096>& joyson::sensor::camera::ChannelFrame::Bits() const
{
    return m_Bits;
}

/*!
 * @brief This function returns a reference to member Bits
 * @return Reference to member Bits
 */
std::array<uint8_t, 1920*1080*2+4096>& joyson::sensor::camera::ChannelFrame::Bits()
{
    return m_Bits;
}

size_t joyson::sensor::camera::ChannelFrame::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;














    return current_align;
}

bool joyson::sensor::camera::ChannelFrame::isKeyDefined()
{
    return false;
}

void joyson::sensor::camera::ChannelFrame::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
               
}

joyson::sensor::camera::GroupFrame::GroupFrame()
{
    // m_GroupTimeStamp com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@679b62af

    // m_FrameIdx com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4d339552
    m_FrameIdx = 0;
    // m_FrameVector com.eprosima.idl.parser.typecode.SequenceTypeCode@f0f2775


}

joyson::sensor::camera::GroupFrame::~GroupFrame()
{



}

joyson::sensor::camera::GroupFrame::GroupFrame(
        const GroupFrame& x)
{
    m_GroupTimeStamp = x.m_GroupTimeStamp;
    m_FrameIdx = x.m_FrameIdx;
    m_FrameVector = x.m_FrameVector;
}

joyson::sensor::camera::GroupFrame::GroupFrame(
        GroupFrame&& x) noexcept 
{
    m_GroupTimeStamp = std::move(x.m_GroupTimeStamp);
    m_FrameIdx = x.m_FrameIdx;
    m_FrameVector = std::move(x.m_FrameVector);
}

joyson::sensor::camera::GroupFrame& joyson::sensor::camera::GroupFrame::operator =(
        const GroupFrame& x)
{

    m_GroupTimeStamp = x.m_GroupTimeStamp;
    m_FrameIdx = x.m_FrameIdx;
    m_FrameVector = x.m_FrameVector;

    return *this;
}

joyson::sensor::camera::GroupFrame& joyson::sensor::camera::GroupFrame::operator =(
        GroupFrame&& x) noexcept
{

    m_GroupTimeStamp = std::move(x.m_GroupTimeStamp);
    m_FrameIdx = x.m_FrameIdx;
    m_FrameVector = std::move(x.m_FrameVector);

    return *this;
}

bool joyson::sensor::camera::GroupFrame::operator ==(
        const GroupFrame& x) const
{

    return (m_GroupTimeStamp == x.m_GroupTimeStamp && m_FrameIdx == x.m_FrameIdx && m_FrameVector == x.m_FrameVector);
}

bool joyson::sensor::camera::GroupFrame::operator !=(
        const GroupFrame& x) const
{
    return !(*this == x);
}

size_t joyson::sensor::camera::GroupFrame::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += joyson::sensor::camera::TimeStamp::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += joyson::sensor::camera::ChannelFrame::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t joyson::sensor::camera::GroupFrame::getCdrSerializedSize(
        const joyson::sensor::camera::GroupFrame& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += joyson::sensor::camera::TimeStamp::getCdrSerializedSize(data.GroupTimeStamp(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.FrameVector().size(); ++a)
    {
        current_alignment += joyson::sensor::camera::ChannelFrame::getCdrSerializedSize(data.FrameVector().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void joyson::sensor::camera::GroupFrame::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_GroupTimeStamp;
    scdr << m_FrameIdx;
    scdr << m_FrameVector;

}

void joyson::sensor::camera::GroupFrame::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_GroupTimeStamp;
    dcdr >> m_FrameIdx;
    dcdr >> m_FrameVector;
}

/*!
 * @brief This function copies the value in member GroupTimeStamp
 * @param _GroupTimeStamp New value to be copied in member GroupTimeStamp
 */
void joyson::sensor::camera::GroupFrame::GroupTimeStamp(
        const joyson::sensor::camera::TimeStamp& _GroupTimeStamp)
{
    m_GroupTimeStamp = _GroupTimeStamp;
}

/*!
 * @brief This function moves the value in member GroupTimeStamp
 * @param _GroupTimeStamp New value to be moved in member GroupTimeStamp
 */
void joyson::sensor::camera::GroupFrame::GroupTimeStamp(
        joyson::sensor::camera::TimeStamp&& _GroupTimeStamp)
{
    m_GroupTimeStamp = std::move(_GroupTimeStamp);
}

/*!
 * @brief This function returns a constant reference to member GroupTimeStamp
 * @return Constant reference to member GroupTimeStamp
 */
const joyson::sensor::camera::TimeStamp& joyson::sensor::camera::GroupFrame::GroupTimeStamp() const
{
    return m_GroupTimeStamp;
}

/*!
 * @brief This function returns a reference to member GroupTimeStamp
 * @return Reference to member GroupTimeStamp
 */
joyson::sensor::camera::TimeStamp& joyson::sensor::camera::GroupFrame::GroupTimeStamp()
{
    return m_GroupTimeStamp;
}
/*!
 * @brief This function sets a value in member FrameIdx
 * @param _FrameIdx New value for member FrameIdx
 */
void joyson::sensor::camera::GroupFrame::FrameIdx(
        uint64_t _FrameIdx)
{
    m_FrameIdx = _FrameIdx;
}

/*!
 * @brief This function returns the value of member FrameIdx
 * @return Value of member FrameIdx
 */
uint64_t joyson::sensor::camera::GroupFrame::FrameIdx() const
{
    return m_FrameIdx;
}

/*!
 * @brief This function returns a reference to member FrameIdx
 * @return Reference to member FrameIdx
 */
uint64_t& joyson::sensor::camera::GroupFrame::FrameIdx()
{
    return m_FrameIdx;
}

/*!
 * @brief This function copies the value in member FrameVector
 * @param _FrameVector New value to be copied in member FrameVector
 */
void joyson::sensor::camera::GroupFrame::FrameVector(
        const std::vector<joyson::sensor::camera::ChannelFrame>& _FrameVector)
{
    m_FrameVector = _FrameVector;
}

/*!
 * @brief This function moves the value in member FrameVector
 * @param _FrameVector New value to be moved in member FrameVector
 */
void joyson::sensor::camera::GroupFrame::FrameVector(
        std::vector<joyson::sensor::camera::ChannelFrame>&& _FrameVector)
{
    m_FrameVector = std::move(_FrameVector);
}

/*!
 * @brief This function returns a constant reference to member FrameVector
 * @return Constant reference to member FrameVector
 */
const std::vector<joyson::sensor::camera::ChannelFrame>& joyson::sensor::camera::GroupFrame::FrameVector() const
{
    return m_FrameVector;
}

/*!
 * @brief This function returns a reference to member FrameVector
 * @return Reference to member FrameVector
 */
std::vector<joyson::sensor::camera::ChannelFrame>& joyson::sensor::camera::GroupFrame::FrameVector()
{
    return m_FrameVector;
}

size_t joyson::sensor::camera::GroupFrame::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool joyson::sensor::camera::GroupFrame::isKeyDefined()
{
    return false;
}

void joyson::sensor::camera::GroupFrame::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}



